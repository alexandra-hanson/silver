grammar silver:extension:bidirtransform;

imports silver:definition:env;
imports silver:definition:core;
imports silver:definition:concrete_syntax;
imports silver:definition:type;
imports silver:definition:type:syntax;
imports silver:extension:convenience;
imports silver:extension:list;
imports silver:extension:patternmatching;
imports silver:util;
imports silver:modification:let_fix;
imports silver:modification:primitivepattern; 
imports silver:modification:copper; 
imports silver:modification:defaultattr;
imports silver:modification:ffi;
imports silver:modification:autocopyattr;
imports silver:modification:impide;

terminal Transform_kwd 'transform' lexer classes {KEYWORD};
terminal Rewrite_kwd 'rewrite' lexer classes {KEYWORD,RESERVED};
terminal From_kwd 'from' lexer classes{KEYWORD,RESERVED};
terminal DblArrow_kwd '->>' lexer classes{KEYWORD, RESERVED};

concrete production transformAGDclFull
ag::AGDcls ::= 'transform' trList::TransformList 
    'rewrite' '{' rwRules::RewriteRuleList '}' 
    -- 'from' cncGroupName::QName 'to' absGroupName::QName ';'
    'from' cncGroupIn::NonterminalList 'to' absGroupIn::NonterminalList '->>' subAg::AGDcls
{
    ag.pp = "transmute " ++ trList.pp ++ " rewrite {" ++ rwRules.pp ++ "}" ++ "->>" ++ subAg.pp;

    default annotation location = ag.location;

    local absGroup::Decorated NonterminalList = decorate absGroupIn with { env=ag.env; };
    local cncGroup::Decorated NonterminalList = decorate cncGroupIn with { env=ag.env; };

    ----------------
    -- Propagation of attributes

    ag.errors := trList.errors ++ rwRules.errors;

    trList.downSubst = emptySubst();
    trList.finalSubst = rwRules.upSubst;

    rwRules.downSubst = emptySubst();    
    rwRules.finalSubst = trList.finalSubst;

    -- todo: think about the env we're providing to the transform/rewrite rules

    -----------------
    -- Initialization of lists of things we need to know
    
    -- We need to know everything's name

    local absNames :: [String] = map((.name), absGroup.ntList);    
    local cncNames :: [String] = map((.name), cncGroup.ntList);
    local locCncNames :: [String] = [];
    local nonLocCncNames :: [String] = cncNames;
    local allNames :: [String] = cncNames ++ absNames;

    -- We need to know all the productions on all of the known types

    local absProdDcls :: [[Decorated NamedSignature]] = map((.ntProds), absGroup.ntList);
    local cncProdDcls :: [[Decorated NamedSignature]] = map((.ntProds), cncGroup.ntList);
    local locCncProdDcls :: [[Decorated NamedSignature]] = [];
    local nonLocCncProdDcls :: [[Decorated NamedSignature]] = cncProdDcls;
    local allProdDcls :: [[Decorated NamedSignature]] = absProdDcls ++ cncProdDcls;

    -----------------------
    -- Generating code

    -- New attributes and annotations

    local agDcls::AGDcl = foldl(\ agDcl::AGDcl trDcl::TransformDcl ->
            appendAGDcl(declareTNameAttributes(trDcl.name), agDcl)
        emptyAGDcl(), trList.transformDcls)

    -- Rewrite rule manipulation
    --
    -- add the identity rule for each type, if an identity rule doesn't already exist
    -- (x -> new(x)) 
    local newRwRules::Decorated RewriteRuleList = foldl(\ rules::Decorated RewriteRuleList name::String ->
            if hasRwID(rules.rewriteRules, name, name) then rules
            else decorate rewriteRuleCons(terminal(Vbar_kwd, "|"), 
                rewriteRuleType(qName(ag.location, "a"), '::', qTyExpr(qName(ag.location, name)), '->',
                    mkNew("a")), 
                    new(rules)) with {
                        absGroup=rules.absGroup;
                        cncGroup=rules.cncGroup;
                        env=rules.env;
                        downSubst=rules.downSubst;
                        finalSubst=rules.finalSubst;
                        config=rules.config;
                    },
        decorate rwRules with {
            absGroup=absGroup;
            cncGroup=cncGroup;
            env=ag.env;
            downSubst=emptySubst();
            finalSubst=trList.finalSubst;
            config=ag.config;
        }, cncNames);

    local toForward::AGDcl = joinAGDcls([
        -- Aspecting origin productions
        restoredCncAttributes(cncNames, newRwRules),
        -- Non-origin aspecting
        absWasTransformed(absProdDcls),
        restoredCncDefinition(absProdDcls, cncNames, newRwRules),
        tNameDefinition(absProdDcls, trList.transformDcl, absGroup, cncGroup),
        transformNameDefinition(absProdDcls, trList.transformDcl, absGroup, cncGroup),
        inhRedexDefinition(absProdDcls, trList.transformDcl, absGroup, cncGroup),
        locationOriginDefinition(locCncProdDcls),
        bottomOriginDefinition(nonLocCncProdDcls),
        -- Origin definitions
        applyOrigins(absGroup.ntList),
        cncApplyOrigins(cncGroup.ntList),
    ]);

    ag.moduleNames = [];--agDclsP3.moduleNames ++ subAg.moduleNames;
    ag.mdaSpecs = toForward.mdaSpecs ++ subAg.mdaSpecs;
    ag.ideSpecs = toForward.ideSpecs ++ subAg.ideSpecs;
    ag.syntaxAst = toForward.syntaxAst ++ subAg.syntaxAst;
    ag.parserSpecs = toForward.parserSpecs ++ subAg.parserSpecs;
    ag.flowDefs = toForward.flowDefs ++ subAg.flowDefs;
    ag.docs := toForward.docs ++ subAg.docs;
    ag.docsHeader = toForward.docsHeader ++ subAg.docsHeader;
    ag.docsSplit = toForward.docsSplit ++ subAg.docsSplit;
    ag.docsNoDoc = toForward.docsNoDoc || subAg.docsNoDoc;
    ag.docDcls := toForward.docDcls ++ subAg.docDcls;
    ag.genFiles := toForward.genFiles ++ subAg.genFiles;
    ag.setupInh := toForward.setupInh ++ subAg.setupInh;
    ag.initProd := toForward.initProd ++ subAg.initProd;
    ag.initValues := toForward.initValues ++ subAg.initValues;
    ag.postInit := toForward.postInit ++ subAg.postInit;
    ag.initWeaving := toForward.initWeaving ++ subAg.initWeaving;
    ag.valueWeaving := toForward.valueWeaving ++ subAg.valueWeaving;
    ag.errors <- toForward.errors ++ subAg.errors;

    toForward.compiledGrammars = ag.compiledGrammars;
    toForward.config = ag.config;    
    toForward.grammarName = ag.grammarName;
    toForward.flowEnv = ag.flowEnv;

    toForward.env = subAg.env;
    subAg.env = appendEnv(ag.env, toEnv(toForward.defs));

    ag.defs = subAg.defs; 
}