grammar silver:extension:bidirtransform;

imports silver:definition:env;
imports silver:definition:core;
imports silver:definition:concrete_syntax;
imports silver:definition:type;
imports silver:definition:type:syntax;
imports silver:extension:convenience;
imports silver:extension:list;
imports silver:extension:patternmatching;
imports silver:util;
imports silver:modification:let_fix;
imports silver:modification:primitivepattern; 
imports silver:modification:copper; 
imports silver:modification:defaultattr;
imports silver:modification:ffi;
imports silver:modification:autocopyattr;
imports silver:modification:impide;

terminal Transform_kwd 'transform' lexer classes {KEYWORD};
terminal Rewrite_kwd 'rewrite' lexer classes {KEYWORD,RESERVED};
terminal From_kwd 'from' lexer classes{KEYWORD,RESERVED};
terminal DblArrow_kwd '->>' lexer classes{KEYWORD, RESERVED};

concrete production transformAGDclFull
ag::AGDcls ::= 'transform' qn::QName '::' transType::TypeExpr 
    '{' trRules::TransformRuleList '}' 
    'rewrite' '{' rwRules::RewriteRuleList '}' 
    -- 'from' cncGroupName::QName 'to' absGroupName::QName ';'
    'from' cncGroupIn::NonterminalList 'to' absGroupIn::NonterminalList '->>' subAg::AGDcls
{
    ag.pp = "transmute " ++ qn.pp ++ "::" ++ transType.pp ++
        "{" ++ trRules.pp ++ "} rewrite {" ++ rwRules.pp ++ "};";

    local tName::String = unFull(qn.name);

    local absGroup::Decorated NonterminalList = decorate absGroupIn with { env=ag.env; };
    local cncGroup::Decorated NonterminalList = decorate cncGroupIn with { env=ag.env; };

    ----------------
    -- Propagation of attributes

    ag.errors := trRules.errors ++ rwRules.errors;

    trRules.absGroup = absGroup;
    trRules.cncGroup = cncGroup;
    trRules.env = ag.env;
    trRules.config = ag.config;
    trRules.downSubst = emptySubst();
    trRules.finalSubst = rwRules.upSubst;

    rwRules.absGroup = absGroup;
    rwRules.cncGroup = cncGroup;
    rwRules.downSubst = emptySubst();    
    rwRules.env = ag.env;
    rwRules.finalSubst = trRules.finalSubst;
    rwRules.config = ag.config;    

    -- todo: think about the env we're providing to the transform/rewrite rules

    -----------------
    -- Initialization of lists of things we need to know
    
    -- We need to know everything's name

    local absNames :: [String] = map((.name), absGroup.ntList);    
    local cncNames :: [String] = map((.name), cncGroup.ntList);
    local locCncNames :: [String] = [];
    local nonLocCncNames :: [String] = cncNames;
    local allNames :: [String] = cncNames ++ absNames;

    -- We need to know all the productions on all of the known types

    local absProdDcls :: [[Decorated NamedSignature]] = map((.ntProds), absGroup.ntList);
    local cncProdDcls :: [[Decorated NamedSignature]] = map((.ntProds), cncGroup.ntList);
    local locCncProdDcls :: [[Decorated NamedSignature]] = [];
    local nonLocCncProdDcls :: [[Decorated NamedSignature]] = cncProdDcls;
    local allProdDcls :: [[Decorated NamedSignature]] = absProdDcls ++ cncProdDcls;

    -----------------------
    -- Generating code

    -- New attributes and annotations

    local inhRedexName::String = inhRedexNm(tName);

    -- autocopy attribute inRedex_$tName :: Maybe<Origin>; 
    local agDcls::AGDcl = autocAttr(inhRedexName, mkMaybeTypeExpr("Origin", location=ag.location), location=ag.location);

    -- for $cncType in cncTypes
    -- synthesized attribute restored$cncType :: $cncType;
    local agDcls2::AGDcl = foldl(\ agDcls::AGDcl name::String-> 
            appendAGDcl(synAttr(restoreNm(unFull(name)), sTyExpr(name, location=ag.location), location=ag.location), agDcls, location=ag.location),
        agDcls, cncNames);

    -- synthesized attribute $tName :: $tType;
    local agDcls3::AGDcl = appendAGDcl(synAttr(tName, transType, location=ag.location), agDcls2, location=ag.location);

    -- synthesized attribute transformed_$tName :: Boolean;
    local agDcls4::AGDcl = appendAGDcl(synAttr(transformNm(tName), mkBoolTypeExpr(location=ag.location), location=ag.location), agDcls3, location=ag.location);    

    -- Occurances of attributes, annotations

    -- Problem in future: only apply this on attributes that they are not 
    -- already defined on. This doesn't work because checking if an attribute
    -- occurs on an element we're working with causes a loop.

    -- for $type in allTypes
    -- attribute inhRedex_$tName occurs on $type;
    local agDcls5::AGDcl = appendAGDcl(attrOn(inhRedexName, allNames, location=ag.location), agDcls4, location=ag.location);
    
    -- for $absType in absTypes
    -- attribute restored$cncType occurs on Origin, $absType;
    local agDcls6::AGDcl = foldl(\ agDcls::AGDcl name::String->
            appendAGDcl(attrOn(restoreNm(unFull(name)), absNames ++ ["Origin"], location=ag.location), agDcls, location=ag.location),
        agDcls5, cncNames);

    -- attribute transformed_$tName occurs on $absType;
    local agDcls7::AGDcl = appendAGDcl(attrOn(transformNm(tName), absNames, location=ag.location), agDcls6, location=ag.location);  

    -- attribute $tName occurs on $absType;
    local agDcls8::AGDcl = appendAGDcl(attrOn(tName, absNames, location=ag.location), agDcls7, location=ag.location);      

    -- Rewrite rule manipulation
    --
    -- add the identity rule for each type, if an identity rule doesn't already exist
    -- (x -> new(x)) 
    local newRwRules::Decorated RewriteRuleList = foldl(\ rules::Decorated RewriteRuleList name::String ->
            if hasRwID(rules.rewriteRules, name, name) then rules
            else decorate rewriteRuleCons(terminal(Vbar_kwd, "|"), 
                rewriteRuleType(qName(ag.location, "a"), '::', qTyExpr(qName(ag.location, name), location=ag.location), '->',
                    mkNew("a", location=ag.location), location=ag.location), 
                    new(rules), location=ag.location) with {
                        absGroup=rules.absGroup;
                        cncGroup=rules.cncGroup;
                        env=rules.env;
                        downSubst=rules.downSubst;
                        finalSubst=rules.finalSubst;
                        config=rules.config;
                    },
        decorate rwRules with {
            absGroup=absGroup;
            cncGroup=cncGroup;
            env=ag.env;
            downSubst=emptySubst();
            finalSubst=trRules.finalSubst;
            config=ag.config;
        }, cncNames);

    -- Aspecting origin productions
    local agDcls9::AGDcl = appendAGDcl(restoredCncAttributes(cncNames, newRwRules), agDcls8, location=ag.location);

    -- Non-origin aspecting
    local agDcls10::AGDcl = appendAGDcl(absWasTransformed(
        absProdDcls, location=ag.location), agDcls9, location=ag.location);
        
    local agDcls11::AGDcl = appendAGDcl(restoredCncDefinition(
        absProdDcls, cncNames, newRwRules, location=ag.location), agDcls10, location=ag.location);

    local agDcls12::AGDcl = appendAGDcl(tNameDefinition(
        absProdDcls, trRules, absGroup, cncGroup, location=ag.location), agDcls11, location=ag.location);

    local agDcls13::AGDcl = appendAGDcl(transformNameDefinition(
        absProdDcls, trRules, absGroup, cncGroup, location=ag.location), agDcls12, location=ag.location);

    local agDcls14::AGDcl = appendAGDcl(inhRedexDefinition(
        absProdDcls, trRules, absGroup, cncGroup, location=ag.location), agDcls13, location=ag.location);

    local agDcls15::AGDcl = appendAGDcl(locationOriginDefinition(
        locCncProdDcls, location=ag.location), agDcls14, location=ag.location);

    local agDcls16::AGDcl = appendAGDcl(bottomOriginDefinition(
        nonLocCncProdDcls, location=ag.location), agDcls15, location=ag.location);

    local toForward::AGDcl = appendAGDcl(
        applyOrigins(absGroup.ntList, location=ag.location), 
        appendAGDcl(
            cncApplyOrigins(cncGroup.ntList, location=ag.location),
            agDcls16, location=ag.location), location=ag.location);


    ag.moduleNames = [];--agDclsP3.moduleNames ++ subAg.moduleNames;
    ag.mdaSpecs = toForward.mdaSpecs ++ subAg.mdaSpecs;
    ag.ideSpecs = toForward.ideSpecs ++ subAg.ideSpecs;
    ag.syntaxAst = toForward.syntaxAst ++ subAg.syntaxAst;
    ag.parserSpecs = toForward.parserSpecs ++ subAg.parserSpecs;
    ag.flowDefs = toForward.flowDefs ++ subAg.flowDefs;
    ag.docs := toForward.docs ++ subAg.docs;
    ag.docsHeader = toForward.docsHeader ++ subAg.docsHeader;
    ag.docsSplit = toForward.docsSplit ++ subAg.docsSplit;
    ag.docsNoDoc = toForward.docsNoDoc || subAg.docsNoDoc;
    ag.docDcls := toForward.docDcls ++ subAg.docDcls;
    ag.genFiles := toForward.genFiles ++ subAg.genFiles;
    ag.setupInh := toForward.setupInh ++ subAg.setupInh;
    ag.initProd := toForward.initProd ++ subAg.initProd;
    ag.initValues := toForward.initValues ++ subAg.initValues;
    ag.postInit := toForward.postInit ++ subAg.postInit;
    ag.initWeaving := toForward.initWeaving ++ subAg.initWeaving;
    ag.valueWeaving := toForward.valueWeaving ++ subAg.valueWeaving;
    ag.errors <- toForward.errors ++ subAg.errors;

    toForward.compiledGrammars = ag.compiledGrammars;
    subAg.compiledGrammars = ag.compiledGrammars;

    toForward.config = ag.config;    
    subAg.config = ag.config;

    toForward.grammarName = ag.grammarName;
    subAg.grammarName = ag.grammarName;

    toForward.flowEnv = ag.flowEnv;
    subAg.flowEnv = ag.flowEnv;

    toForward.env = subAg.env;
    subAg.env = appendEnv(ag.env, toEnv(toForward.defs));
    --subAg.env = newScopeEnv(toForward.defs, ag.env); -- did not work
    --subAg.env = ag.env; -- did not work

    -- ag.defs = toForward.defs ++ subAg.defs; -- <- duplicate attributes
    ag.defs = subAg.defs; 

    --ag.liftedAGDcls = agDcls22; 
    --forwards to consAGDcls(agDclsP3, subAg, location=ag.location);
}